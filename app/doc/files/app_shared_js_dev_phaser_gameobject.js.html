<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>app\shared\js\dev\phaser\gameobject.js - LREditor API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="LREditor API"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Behaviour.Button.html">Behaviour.Button</a></li>
                                <li><a href="../classes/Behaviour.LR.Editor.Behaviour.ScrollerVertical.html">Behaviour.LR.Editor.Behaviour.ScrollerVertical</a></li>
                                <li><a href="../classes/Behaviour.ScrollerHorizontal.html">Behaviour.ScrollerHorizontal</a></li>
                                <li><a href="../classes/Behaviour.Trigger.html">Behaviour.Trigger</a></li>
                                <li><a href="../classes/Behaviour.TriggerChangeLevel.html">Behaviour.TriggerChangeLevel</a></li>
                                <li><a href="../classes/Behaviour.TriggerCutscene.html">Behaviour.TriggerCutscene</a></li>
                                <li><a href="../classes/Editor.AssetManager.html">Editor.AssetManager</a></li>
                                <li><a href="../classes/Editor.LevelImporterEditor.html">Editor.LevelImporterEditor</a></li>
                                <li><a href="../classes/Entity.BitmapText.html">Entity.BitmapText</a></li>
                                <li><a href="../classes/Entity.Button.html">Entity.Button</a></li>
                                <li><a href="../classes/Entity.Sprite.html">Entity.Sprite</a></li>
                                <li><a href="../classes/Entity.Text.html">Entity.Text</a></li>
                                <li><a href="../classes/Entity.TileSprite.html">Entity.TileSprite</a></li>
                                <li><a href="../classes/LR.Behaviour.html">LR.Behaviour</a></li>
                                <li><a href="../classes/LR.Body.html">LR.Body</a></li>
                                <li><a href="../classes/LR.CollisionManager.html">LR.CollisionManager</a></li>
                                <li><a href="../classes/LR.Game.html">LR.Game</a></li>
                                <li><a href="../classes/LR.GameObject.html">LR.GameObject</a></li>
                                <li><a href="../classes/LR.LevelExporter.html">LR.LevelExporter</a></li>
                                <li><a href="../classes/LR.LevelImporter.html">LR.LevelImporter</a></li>
                                <li><a href="../classes/LR.LevelImporterGame.html">LR.LevelImporterGame</a></li>
                                <li><a href="../classes/LR.LevelUtilities.html">LR.LevelUtilities</a></li>
                                <li><a href="../classes/LR.LR.html">LR.LR</a></li>
                                <li><a href="../classes/LR.State.html">LR.State</a></li>
                                <li><a href="../classes/LR.Utils.html">LR.Utils</a></li>
                                <li><a href="../classes/Misc.TriggerMessageObject.html">Misc.TriggerMessageObject</a></li>
                                <li><a href="../classes/Phaser.Plugin..Pollinator.html">Phaser.Plugin..Pollinator</a></li>
                                <li><a href="../classes/Phaser.Plugin.CutsceneManager.html">Phaser.Plugin.CutsceneManager</a></li>
                                <li><a href="../classes/Phaser.Plugin.DialogManager.html">Phaser.Plugin.DialogManager</a></li>
                                <li><a href="../classes/Phaser.Plugin.InputManager.html">Phaser.Plugin.InputManager</a></li>
                                <li><a href="../classes/Phaser.Plugin.PlayerSave.html">Phaser.Plugin.PlayerSave</a></li>
                                <li><a href="../classes/UI.DialogBox.html">UI.DialogBox</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: app\shared\js\dev\phaser\gameobject.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        &quot;use strict&quot;;
                        /**
                        * Base object 
                        *
                        * @namespace LR
                        * @class GameObject
                        * @constructor
                        * @param {LR.Sprite | LR.Group | LR.TileSprite} LR entity
                        */
                        LR.GameObject = function(_entity) {
                        	/**
                        	* ID of the gameobject
                        	*
                        	* @property id
                        	* @type Number
                        	* @default -1
                        	*/
                        	this.id = -1;
                        	/*
                        	* LR entity
                        	* 
                        	* @property entity
                        	* @type {LR.Sprite | LR.Group | LR.TileSprite}
                        	* @default null
                        	*/
                        	this.entity = _entity;
                        
                        	/**
                        	* The collision layer index used to filter collisions
                        	* @property layer
                        	* @type {string}
                        	* @default &quot;default&quot;
                        	*/
                        	this.layer = &quot;default&quot;;
                        	
                        	/**
                        	* The behaviours attached to the gameobject
                        	* @property behaviours
                        	* @type {Array}
                        	* @default array
                        	*/
                        	this.behaviours = new Array();
                        
                        	/**
                        	* Sounds that can be played by the GameObject. Contains Phaser.Sound objects.
                        	*
                        	* @property sounds
                        	* @type Object
                        	* @default {}
                        	*/
                        	this.sounds = new Object();
                        
                        	this._3DSounds = null;
                        
                        	/**
                        	* A reference to the current CollisionManager. Set when the GameObject is added to the CollisionManager
                        	* @property collisionManager
                        	* @type {CollisionManager}
                        	* @default null
                        	*/
                        	this.collisionManager = null;
                        
                        	/*
                        	* If this is enabled, the gameobject will send contact events to its behaviours. Use enableEvents().
                        	* @property enableContactEvents
                        	* @type {boolean}
                        	* @default false
                        	*/
                        	this.enableContactEvents = false;
                        
                        	this.debugBounds = false;
                        
                        	if( _entity != null ){
                        		/**
                        		* Reference to the game
                        		*
                        		* @property game
                        		* @type Phaser.Game
                        		* @default null
                        		*/
                        		this.game = _entity.game;
                        		this.entity.gameobject = this;
                        	}
                        
                        	//broadphase
                        	this.broadphaseListened = false;
                        	this.postBroadphaseCallback = null;
                        	this.postBroadphaseContext = null;
                        
                        	/**
                        	* Signal dispatched when a tween is complete
                        	*
                        	* @property onTweenComplete
                        	* @type {Phaser.Signal}
                        	*/
                        	this.onTweenComplete = new Phaser.Signal();
                        
                        	//behaviours to remove
                        	this._behavioursToRemove = new Array();
                        
                        	this.tweensData = new Object();
                        };
                        
                        LR.GameObject.prototype.constructor = LR.GameObject;
                        
                        // Called when the scene is launching. All objects are created then.
                        LR.GameObject.prototype.start = function() {
                        	if (this.entity.exists &amp;&amp; this.behaviours) {
                        		for(var i=0; i &lt; this.behaviours.length; i++){
                        			if( this.behaviours[i].start != null &amp;&amp; this.behaviours[i].enabled )
                        				this.behaviours[i].start();
                        		}
                        	}
                        };
                        
                        LR.GameObject.prototype.update = function() {
                        	if (this.entity.exists &amp;&amp; this.behaviours) {
                        		var canUpate = true;
                        		if (this.entity.game.state.forbidUpdate == true) {
                        			canUpate = false;
                        		}
                        
                        		if (canUpate) {
                        			for(var i=0; i &lt; this.behaviours.length; i++){
                        				if( this.behaviours[i].update != null &amp;&amp; this.behaviours[i].enabled  )
                        					this.behaviours[i].update();
                        			}
                        		}
                        	}
                        	//3DSounds
                        	if(this.entity.exists &amp;&amp; this._3DSounds != null){
                        		this._update3DSounds();
                        	}
                        };
                        
                        LR.GameObject.prototype.postUpdate = function() {
                        	if (this.entity.exists &amp;&amp; this._behavioursToRemove.length &gt; 0) {
                        		for(var r=0; r &lt; this._behavioursToRemove.length; r++){
                        			var bh = this._behavioursToRemove[r];
                        			for( var i = 0; i &lt; this.behaviours.length; i++){
                        				if( this.behaviours[i] === bh){
                        					this.behaviours.splice(i,1);
                        				}
                        			}
                        		}
                        	}
                        	//call postUpdate of behaviours
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		if( this.behaviours[i].postUpdate != null)
                        			this.behaviours[i].postUpdate();
                        	}
                        };
                        
                        LR.GameObject.prototype.render = function() {
                        	if( this.entity.exists ){
                        		for(var i=0; i &lt; this.behaviours.length; i++){
                        			if( this.behaviours[i].render != null &amp;&amp; this.behaviours[i].enabled  )
                        				this.behaviours[i].render();
                        		}
                        	}
                        };
                        
                        LR.GameObject.prototype.destroy = function() {
                        	if( this.entity.exists ){
                        		for(var i=0; i &lt; this.behaviours.length; i++){
                        			if( this.behaviours[i].destroy != null )
                        				this.behaviours[i].destroy();
                        		}
                        		this.behaviours = new Array();
                        	}
                        	//clear collisions on the body
                        	if( this.entity.body != null ){
                        		this.entity.body.clearCollision(true,true);
                        		this.removePhysics();
                        	}
                        };
                        
                        //============================================================
                        //						PHYSICS
                        //============================================================
                        
                        /**
                        * Creates a body and enable physics for the gameobject
                        * Also creates a variable go in the {P2.Body} body
                        *
                        * @method enablePhysics
                        * @param {number} motionState : pick STATIC, KINEMATIC or DYNAMIC from Phaser.Physics.P2.Body. Default is DYNAMIC
                        * @param {string} layer : the layer of collision. null will let it to &quot;default&quot;.
                        * @param {number} &lt;optional&gt; width : new width of the body rectangle. Won&#x27;t do anything without height.
                        * @param {number} &lt;optional&gt; height : new height of the body rectangle
                        */
                        LR.GameObject.prototype.enablePhysics = function(_motionState,_layer,_width,_height){
                        	if( this.body == null){
                        		if (this.entity.hasOwnProperty(&#x27;body&#x27;) &amp;&amp; this.entity.body === null)
                                {
                                    this.entity.body = new LR.Body(this.game, this.entity, this.entity.x, this.entity.y, 1);
                                    //this.entity.game.physics.p2.enable(this.entity,false);
                                    this.entity.anchor.set(0.5);
                                }
                        		this.body.data.shapes[0].lr_name = &quot;mainShape&quot;;
                        	}
                        
                        	this.body.go = this;
                        	this.body.debug = this.debugBounds;
                        	// Set Motion State
                        	this.setMotionState(_motionState);
                        	//LAYER
                        	if( _layer != null )
                        		this.layer = _layer;
                        	//Set Rectangle
                        	if( _width != null &amp;&amp; _height != null ){
                        		this.body.setRectangle(_width,_height,0,0,0);
                        	}
                        	return this.entity.body;
                        }
                        
                        
                        
                        /**
                        * Removes the body from the world 
                        *
                        * @method removePhysics
                        */
                        LR.GameObject.prototype.removePhysics = function(){
                        	if( this.entity.body != null){
                        		this.entity.body.removeFromWorld();
                        		this.entity.body.destroy();
                        	}
                        }
                        
                        /**
                        * Enables the behaviours of the gameobject to receive the contact events
                        * Without that, onBeginContact and onEndContact are never called
                        * @method enableEvents 
                        */
                        LR.GameObject.prototype.enableEvents = function(){
                        	this.enableContactEvents = true;
                        	if( this.body != null ){
                        		this.body.onBeginContact.add(this.onBeginContact, this);
                        		this.body.onEndContact.add(this.onEndContact, this);
                        	}
                        }
                        
                        /**
                        * Disable the behaviours of the gameobject to receive the contact events
                        * The onBeginContact and onEndContact will not be called anymore
                        * @method disableEvents 
                        */
                        LR.GameObject.prototype.disableEvents = function(){
                        	this.enableContactEvents = false;
                        	if( this.body != null ){
                        		this.body.onBeginContact.remove(this.onBeginContact, this);
                        		this.body.onEndContact.remove(this.onEndContact, this);
                        	}
                        }
                        
                        /**
                        * Enables the sensor behaviour of the shapes of the GameObject
                        * @method enableSensor
                        * @param {Array} indexes Array of indexes of the shapes with we want to be sensors. If null, all the shapes will be sensors.
                        */
                        LR.GameObject.prototype.enableSensor = function(_indexes){
                        	if( this.body == null)
                        		return;
                        	var shapes = this.body.data.shapes;
                        	if(_indexes == null){
                        		for(var i=0 ; i &lt; shapes.length; i++){
                        			shapes[i].sensor = true;
                        		}
                        	}else{
                        		for(var i=0 ; i &lt; _indexes.length; i++){
                        			var index = _indexes[i];
                        			if( index &lt; 0 || index &gt;= shapes.length)
                        				continue;
                        			shapes[index].sensor = true;
                        		}
                        	}
                        }
                        
                        /**
                        * Disables the sensor behaviour of the shapes of the GameObject
                        * @method disableSensor
                        * @param {Array} indexes Array of indexes of the shapes with we want to be physical. If null, all the shapes will be solid.
                        */
                        LR.GameObject.prototype.disableSensor = function(_indexes){
                        	if( this.body == null)
                        		return;
                        	var shapes = this.body.data.shapes;
                        	if(_indexes == null){
                        		for(var i=0 ; i &lt; shapes.length; i++){
                        			shapes[i].sensor = false;
                        		}
                        	}else{
                        		for(var i=0 ; i &lt; _indexes.length; i++){
                        			var index = _indexes[i];
                        			if( index &lt; 0 || index &gt;= shapes.length)
                        				continue;
                        			shapes[index].sensor = false;
                        		}
                        	}
                        }
                        
                        /**
                        * Enable Bounds to be displayed ( if no body is affected yet, this will be effective when one is added )
                        * @method enableDebugBounds
                        */
                        LR.GameObject.prototype.enableDebugBounds = function(){
                        	this.debugBounds = true;
                        	if( this.body == null)
                        		return;
                        	this.body.debug = true;
                        }
                        
                        /**
                        * Disable Bounds display( if no body is affected yet, this will be effective when one is added )
                        * @method disableDebugBounds
                        */
                        LR.GameObject.prototype.disableDebugBounds = function(){
                        	this.debugBounds = false;
                        	if( this.body == null)
                        		return;
                        	this.body.debug = false;
                        }
                        
                        /**
                        * Changes the motion state of the gameobject body
                        *
                        *@method setMotionState
                        *@param {number} motionState PhysicsSettings.STATIC, PhysicsSettings.KINEMATIC or PhysicsSettings.DYNAMIC
                        */
                        LR.GameObject.prototype.setMotionState = function(_motionState){
                        	if(_motionState != null){
                        		this.body.motionState = _motionState;
                        		if( _motionState == Phaser.Physics.P2.Body.STATIC){
                        			this.body.mass = 0;
                        		}else{
                        			this.body.mass = 1;
                        		}
                        	}
                        }
                        
                        /**
                        * Changes the current layer of the object, resetting collisions groups
                        *
                        * @method changeLayer
                        * @param {string} layer
                        */
                        LR.GameObject.prototype.changeLayer = function(_layer){
                        	this.layer = _layer;
                        	if( this.collisionManager != null ){
                        		this.collisionManager.changeGameObjectLayer(this,_layer,this.enableContactEvents);
                        	}
                        }
                        
                        //======================================================================
                        //					CONTACT CALLBACK
                        //======================================================================
                        
                        /**
                        * Sets the callback for the postbroadphase
                        * Postbroadphase is called BEFORE &quot;enabling&quot; any collision. You can then prevent a collision from happening
                        * The callback should return true to validate a collision ( make it effective in game) 
                        * The callback will have the colliding body passed in parameter
                        *
                        * @method setPostBroadPhaseCallback
                        * @param {method} callback
                        * @param {Behaviour} context
                        */
                        LR.GameObject.prototype.setPostBroadPhaseCallback = function(_callback, _context){
                        	this.broadphaseListened = true;
                        	this.postBroadphaseContext = _context;
                        	this.postBroadphaseCallback = _callback;
                        	if( _callback == null || _context == null )
                        		this.broadphaseListened = false;
                        }
                        
                        /**
                        * Called by the CollisionManager when the body of the GameObject is concerned in the postBroadphase
                        * Basically, this method is called before a collision with another body will appear.
                        * You can then decide if you want to let the collision happen 
                        * 
                        * First link your callback with setPostBroadPhaseCallback(callback,context)
                        * The callback method must return true if you want this gameobject to collide with the otherbody, false instead.
                        *
                        * NB: This is called BEFORE onBeginContact
                        *
                        * @method onPostBroadPhase
                        * @param {param_type} param_description
                        */
                        LR.GameObject.prototype.onPostBroadPhase = function(_body){
                        	if( this.postBroadphaseCallback != null){
                        		return this.postBroadphaseCallback .call(this.postBroadphaseContext,_body);
                        	}
                        	return true;
                        }
                        
                        LR.GameObject.prototype.onBeginContact = function(_otherBody, _otherShape, _myShape, _equation){
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		if( this.behaviours[i].onBeginContact != null &amp;&amp; this.behaviours[i].enabled &amp;&amp; this.behaviours[i].enableEvents )
                        			this.behaviours[i].onBeginContact(_otherBody, _otherShape, _myShape, _equation);
                        	}
                        }
                        
                        LR.GameObject.prototype.onContact = function(_body2){
                        	//console.log(&quot;contact!&quot;);
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		if( this.behaviours[i].onContact != null &amp;&amp; this.behaviours[i].enabled &amp;&amp; this.behaviours[i].enableEvents )
                        			this.behaviours[i].onContact(_body2);
                        	}
                        }
                        
                        LR.GameObject.prototype.onEndContact = function(_otherBody, _otherShape, _myShape){
                        	//console.log(&quot;===collision ends from &quot; + this.name);
                        	//console.log(&quot;onBody : &quot; + _otherBody.sprite.go.name);
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		if( this.behaviours[i].onEndContact != null &amp;&amp; this.behaviours[i].enabled &amp;&amp; this.behaviours[i].enableEvents )
                        			this.behaviours[i].onEndContact(_otherBody, _otherShape, _myShape);
                        	}
                        }
                        
                        //============================================================
                        //					BEHAVIOURS
                        //============================================================
                        
                        /**
                        * Adds a behaviour to the gameobject
                        * @method addBehaviour
                        * @param {Behaviour} behaviour Behaviour instance
                        * @return the behaviour 
                        */
                        LR.GameObject.prototype.addBehaviour = function(_behaviour) {
                        	this.behaviours.push(_behaviour);
                        	return _behaviour;
                        }
                        
                        /**
                        * Removes a behaviour from the gameobject
                        * @method removeBehaviour
                        * @param {Behaviour} behaviour Behaviour instance
                        * @return the behaviour 
                        */
                        LR.GameObject.prototype.removeBehaviour = function(_behaviour){
                        	if( _behaviour != null)
                        		this._behavioursToRemove.push( _behaviour );
                        }
                        
                        /**
                        * Returns the requested behaviour. If more than one is attaced, the first one is return. Use getBehaviours if you need them all
                        * This could be expensive. Do not do this at every frame. 
                        * @method getBehaviour
                        * @param {Class} behaviour The behaviour class
                        * @returns {Behaviour} the behaviour, or null if not found
                        */
                        LR.GameObject.prototype.getBehaviour = function( _script ){
                        	for(var i = 0 ; i &lt; this.behaviours.length; i++){
                        		if(this.behaviours[i] instanceof _script)
                        			return this.behaviours[i];
                        	}
                        	return null;
                        }
                        
                        /**
                        * Returns the requested behaviour attached to the GameObject or its children.
                        * If more than one is attached, the first one is return. Use getBehaviours if you need them all
                        * This could be expensive. Do not do this at every frame. 
                        * @method getBehaviourInChildren
                        * @param {Class} behaviour The behaviour class
                        * @returns {Behaviour} the behaviour, or null if not found
                        */
                        LR.GameObject.prototype.getBehaviourInChildren = function( _script ){
                        	for(var i = 0 ; i &lt; this.behaviours.length; i++){
                        		if(this.behaviours[i] instanceof _script)
                        			return this.behaviours[i];
                        	}
                        
                        	if( this.entity.children ){
                        		for( var i=0; i &lt; this.entity.children.length; i++){
                        			var script = this.entity.children[i].go.getBehaviourInChildren(_script);
                        			if( script )
                        				return script;
                        		}
                        	}
                        	return null;
                        }
                        
                        /**
                        * Returns all the requested behaviours attached to the object. 
                        * This could be expensive. Do not do this at every frame. 
                        * @method getBehaviours
                        * @param {Class} behaviour The behaviour class
                        * @returns {Array} the behaviours in an array (might be empty)
                        */
                        LR.GameObject.prototype.getBehaviours = function( _script ){
                        	var array = new Array();
                        	for(var i = 0 ; i &lt; this.behaviours.length; i++){
                        		if(this.behaviours[i] instanceof _script)
                        			return array.push( this.behaviours[i] );
                        	}
                        	return array;
                        }
                        
                        /**
                        * Returns all instances of the requested behaviour class attached to the GameObject and its children.
                        * This may be expensive. Do not do this at every frame. 
                        * @method getBehavioursInChildren
                        * @param {Class} behaviour The behaviour class
                        * @returns {Array} the behaviours in an array (might be empty)
                        */
                        LR.GameObject.prototype.getBehavioursInChildren = function( _script, _array ){
                        	if( _array==null)
                        		_array = new Array();
                        
                        	for(var i = 0 ; i &lt; this.behaviours.length; i++){
                        		if(this.behaviours[i] instanceof _script)
                        			_array.push( this.behaviours[i] );
                        	}
                        
                        	if( this.entity.children ){
                        		for( var i=0; i &lt; this.entity.children.length; i++){
                        			_array.concat( this.entity.children[i].go.getBehavioursInChildren(_script,_array));	
                        		}
                        	}
                        	return _array;
                        }
                        
                        /**
                        * Try to call the function on every behaviour attached to this GameObject 
                        * @method sendMessage
                        * @param {string} functionName
                        * @param {Object} messageObject : You might want to pass an object for the parameter of the function
                        */
                        LR.GameObject.prototype.sendMessage = function(_functionName, _messageObject){
                        	var BH;
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		BH = this.behaviours[i];
                        		//try calling method directly
                        		if( BH[_functionName]){
                        			BH[_functionName](_messageObject);
                        		//if it fails, try calling the prototype&#x27;s function
                        		}else if( BH.prototype &amp;&amp; BH.prototype[_functionName]){
                        			BH.prototype[_functionName].call(BH,_messageObject);
                        		}
                        	}
                        }
                        
                        //============================================================
                        //						SHAPES
                        //============================================================
                        /**
                        * Returns the number of shapes attached to the body
                        *
                        * @method getShapesCount
                        * @return integer
                        */
                        LR.GameObject.prototype.getShapesCount = function(){
                        	if( this.body == null )
                        		return 0;
                        	return this.body.data.shapes.length;
                        }
                        
                        /**
                        * Returns the wanted shape
                        *
                        * @method getShape
                        * @param {number} shapeIndex
                        * @return P2.Shape
                        */
                        LR.GameObject.prototype.getShape = function(_shapeIndex){
                        	if( _shapeIndex == null )
                        		_shapeIndex = 0;
                        	if( this.body ){
                        		if( this.body.data.shapes.length &gt; _shapeIndex ){
                        			return this.body.data.shapes[_shapeIndex];
                        		}
                        	}
                        	return null;
                        }
                        
                        /**
                        * Returns the shape by its name (property lr_name)
                        * If many shapes share the same name, this method will return the first encountered in the shapes array
                        *
                        * @method getShapeByName
                        * @param {number} shapeName The name of the researched shape
                        * @return P2.Shape
                        */
                        LR.GameObject.prototype.getShapeByName = function(_shapeName){
                        	for(var i=0; i &lt; this.getShapesCount(); i++ ){
                        		if( this.getShape(i).lr_name == _shapeName ){
                        			return this.getShape(i);
                        		}
                        	}
                        	return null;
                        }
                        
                        /**
                        * Returns the shapes by their names (property lr_name)
                        * 
                        * @method getShapesByNames
                        * @param {Array} shapeName The names of the researched shapes
                        * @return {Array} shapes found
                        */
                        LR.GameObject.prototype.getShapesByNames = function(_shapesNames){
                        	var shapesFound = new Array();
                        	for(var i=0; i &lt; this.getShapesCount(); i++ ){
                        		for( var iName = 0; iName &lt; _shapesNames.length; iName ++){			
                        			if( this.getShape(i).lr_name == _shapesNames[iName] ){
                        				shapesFound.push( this.getShape(i) );
                        			}
                        		}
                        	}
                        	return shapesFound;
                        }
                        
                        /**
                        * Returns the index of the shape found by its name (property lr_name)
                        * 
                        * @method getShapeIndexByName
                        * @param {Array} shapeName The index of the researched shape
                        * @return {Number} index
                        */
                        LR.GameObject.prototype.getShapeIndexByName = function(_shapeName){
                        	for(var i=0; i &lt; this.getShapesCount(); i++ ){
                        		if( this.getShape(i).lr_name == _shapeName ){
                        			return i;
                        		}
                        	}
                        	return -1;
                        }
                        
                        /**
                        * Returns the size of the wanted shape. You can either pass its index or its name
                        *
                        * @method getShapeData
                        * @param {Number | string} shapeIndexOrName
                        * @return {Object} object containing the following properties : x, y, width, height (in pixels), rotation (in degrees), sensor (bool), name
                        */
                        LR.GameObject.prototype.getShapeData = function(_shapeIndex){
                        	var data = new Object();
                        
                        	if( typeof _shapeIndex == &quot;string&quot;)
                        		_shapeIndex = this.getShapeIndexByName(_shapeIndex);
                        
                        	if( _shapeIndex == null || _shapeIndex &lt; 0)
                        		_shapeIndex = 0;
                        	var shape = this.getShape(_shapeIndex);
                        	if( shape ){
                        		data.x = this.game.physics.p2.mpxi( this.body.data.shapeOffsets[_shapeIndex][0] );
                        		data.y = this.game.physics.p2.mpxi( this.body.data.shapeOffsets[_shapeIndex][1] );
                        		if(LR.Utils.getShapeType(shape) == &quot;rectangle&quot;){
                        			data.width = this.game.physics.p2.mpx( shape.width );
                        			data.height = this.game.physics.p2.mpx( shape.height ); 
                        		}else if(LR.Utils.getShapeType(shape) == &quot;circle&quot;){
                        			data.radius = this.game.physics.p2.mpx(shape.radius);
                        		}
                        		data.rotation = LR.Utils.toDegrees( this.body.data.shapeAngles[_shapeIndex]);
                        		data.sensor = shape.sensor;
                        		data.name = shape.lr_name;
                        		data.type = LR.Utils.getShapeType(shape);
                        	}
                        	return data;
                        }
                        
                        /**
                        * Replaces the shape at the given index with a new Rectangle, creating a new shape from the data provided
                        * This sahpe will be pushed to the end of shapes array if _shapeIndex is incorrect
                        *
                        * @method replaceShapeByRectangle
                        * @param {Number} shapeIndex
                        * @param {Object} data Can contain x {Number}, y{Number}, width{Number}, height{Number}, rotation{Number}, sensor {Boolean} properties, name {String}
                        * @return P2.Shape
                        */
                        LR.GameObject.prototype.replaceShapeByRectangle = function(_shapeIndex, _data){
                        	//Make sure data is set
                        	if( _data.x == null ) _data.x = 0;
                        	if( _data.y == null ) _data.y = 0;
                        	if( _data.width == null ) _data.width = this.entity.width;
                        	if( _data.height == null ) _data.height = this.entity.height;
                        	if( _data.rotation == null ) _data.rotation = 0;
                        
                        	//Create the new Rectangle from input _data
                        	var newShape = new p2.Rectangle(
                        					this.game.physics.p2.pxm( _data.width),
                        					this.game.physics.p2.pxm( _data.height)				
                        				);
                        
                        	//Check index before inserting
                        	if( _shapeIndex &lt; this.body.data.shapes.length &amp;&amp; _shapeIndex &gt;= 0 ){
                        		//keep the former name of the shape
                        		newShape.lr_name = this.body.data.shapes[_shapeIndex].lr_name;
                        		//affect new shape in place of the current one
                        		this.body.data.shapes[_shapeIndex] = newShape;
                        		this.body.data.shapeOffsets[_shapeIndex] = [this.game.physics.p2.pxmi(_data.x), this.game.physics.p2.pxmi(_data.y)];
                        		this.body.data.shapeAngles[_shapeIndex] = LR.Utils.toRadians(_data.rotation);
                        	}else{
                        		//if the _shapeIndex is incorrect, just add the new shape
                        		this.body.data.addShape(newShape,
                        								[this.game.physics.p2.pxmi(_data.x), this.game.physics.p2.pxmi(_data.y)],
                        								LR.Utils.toRadians(_data.rotation));
                        		if( _data.name == null ) 
                        			_data.name = &quot;shape&quot;+ _shapeIndex;
                        		newShape.lr_name = _data.name;
                        	}
                        	//Tells P2 to update the shapes
                        	this.body.data.updateMassProperties();
                            this.body.data.updateBoundingRadius();
                            this.body.data.aabbNeedsUpdate = true;
                            //Tells Phaser.Body to update the shapes
                            this.body.shapeChanged();
                        		
                        	return newShape;
                        }
                        
                        /**
                        * Replaces the shape at the given index with a new Circle, creating a new shape from the data provided
                        * This shape will be pushed to the end of shapes array if _shapeIndex is incorrect
                        *
                        * @method replaceShapeByCircle
                        * @param {Number} shapeIndex
                        * @param {Object} data Can contain x {Number}, y{Number}, radius{Number}, rotation{Number}, sensor {Boolean} properties, name {String}
                        * @return P2.Shape
                        */
                        LR.GameObject.prototype.replaceShapeByCircle = function(_shapeIndex, _data){
                        	//Make sure data is set
                        	if( _data.x == null ) _data.x = 0;
                        	if( _data.y == null ) _data.y = 0;
                        	if( _data.radius == null ) _data.radius = this.entity.radius;
                        	if( _data.rotation == null ) _data.rotation = 0;
                        
                        	//Create the new Circle from input _data
                        	var newShape = new p2.Circle(
                        					this.game.physics.p2.pxm( _data.radius)				
                        				);
                        	//Check index before inserting
                        	if( _shapeIndex &lt; this.body.data.shapes.length &amp;&amp; _shapeIndex &gt;= 0 ){
                        		//keep the former name of the shape
                        		newShape.lr_name = this.body.data.shapes[_shapeIndex].lr_name;
                        		//affect new shape in place of the current one
                        		this.body.data.shapes[_shapeIndex] = newShape;
                        		this.body.data.shapeOffsets[_shapeIndex] = [this.game.physics.p2.pxmi(_data.x), this.game.physics.p2.pxmi(_data.y)];
                        		this.body.data.shapeAngles[_shapeIndex] = LR.Utils.toRadians(_data.rotation);
                        	}else{
                        		//if the _shapeIndex is incorrect, just add the new shape
                        		this.body.data.addShape(newShape,
                        								[this.game.physics.p2.pxmi(_data.x), this.game.physics.p2.pxmi(_data.y)],
                        								LR.Utils.toRadians(_data.rotation));
                        		if( _data.name == null ) 
                        			_data.name = &quot;shape&quot;+ _shapeIndex;
                        		newShape.lr_name = _data.name;
                        	}
                        	//Tells P2 to update the shapes
                        	this.body.data.updateMassProperties();
                            this.body.data.updateBoundingRadius();
                            this.body.data.aabbNeedsUpdate = true;
                            //Tells Phaser.Body to update the shapes
                            this.body.shapeChanged();
                        		
                        	return newShape;
                        }
                        
                        //============================================================
                        //						SOUNDS
                        //============================================================
                        LR.GameObject.prototype.addSound = function(_name,_sound){
                        	this.sounds[_name] = _sound;
                        }
                        
                        /**
                        * Returns the specified sound. If none specified, returns the first sound of the GameObject (if it exists)
                        *
                        * @method getSound
                        * @param {String} name
                        * @return {Phaser.Sound}
                        */
                        LR.GameObject.prototype.getSound = function(_name){
                        	if( _name == null &amp;&amp; Object.keys(this.sounds).length &gt; 0)
                        		return this.sounds[Object.keys(this.sounds)[0]];
                        	return this.sounds[_name];
                        }
                        
                        /**
                        * Plays the specified sound
                        *
                        * @method playSound
                        * @param {String} name
                        * @param {Number} volume 0 &lt;= volume &lt;= 1
                        * @param {boolean} loop
                        * @param {Number} fadeInTime (in ms) If none provided, no fade in
                        */
                        LR.GameObject.prototype.playSound = function(_name,_volume,_loop,_fadeInTime){
                        	var sound = this.sounds[_name];
                        	if(sound){
                        		if( sound.isPlaying ){
                        			sound.stop();
                        		}
                        		if( sound.lr_3D == true){
                        			this._play3DSound(sound,_loop);
                        		}else{
                        			if( _fadeInTime ){
                        				sound.play(&#x27;&#x27;,0,0,_loop);
                        				var tween = this.entity.game.add.tween(sound);
                        				tween.to({volume:_volume}, _fadeInTime).start();
                        			}else{
                        				sound.play(&#x27;&#x27;,0,_volume,_loop);
                        			}
                        		}
                        	}
                        }
                        
                        /**
                        * Stops the specified sound
                        *
                        * @method playSound
                        * @param {String} name Name of the sound to stop
                        * @param {Number} fadeOutTime (in ms) If none provided, no fade out
                        */
                        LR.GameObject.prototype.stopSound = function(_name,_fadeOutTime){
                        	var sound = this.sounds[_name];
                        	if(sound){
                        		if( sound.isPlaying ){
                        			if( _fadeOutTime ){
                        				var tween = this.entity.game.add.tween(sound);
                        				tween.to({volume:0}, _fadeOutTime).start();
                        				tween.onComplete.add(function(){sound.stop();},this);
                        			}else{
                        				sound.stop();
                        			}
                        		}
                        	}
                        }
                        
                        LR.GameObject.prototype._update3DSounds = function(){
                        	//compute distance between the camera&#x27;s center and the GameObject
                        	var d = Phaser.Point.distance(this.entity.world,
                        								new Phaser.Point(this.entity.game.camera.view.centerX,this.entity.game.camera.view.centerY) );
                        	var sound = null;
                        	for( var i=0; i &lt; this._3DSounds.length; i++){
                        		sound = this.sounds[ this._3DSounds[i]];
                        		if(sound == null)
                        			continue;
                        		if( sound.lr_distance3D &lt; d ){
                        			sound.volume = 0;
                        		}else{
                        			sound.volume = (1 - d / sound.lr_distance3D ) * sound.lr_volumeMax3D;
                        		}
                        	}
                        }
                        
                        /**
                        * Enable this specified sound to be 3D
                        * The distance is used to make the sound audible. This is computed from the distance between the center of the camera and the position of the GameObject
                        *
                        * @method enable3DSound
                        * @param {string} Name of the sound
                        * @param {number} Distance where the sound begins to be audible
                        * @param {number} Maximum volume of the sound
                        */
                        LR.GameObject.prototype.enable3DSound = function(_name,_distance,_volumeMax){
                        	var sound = this.getSound(_name);
                        	if( sound == null ){
                        		console.warn(&quot; No sound found to enable 3D audio&quot;);
                        		return;
                        	}
                        	if(_distance == null ) _distance = 300;
                        	if(_volumeMax == null ) _volumeMax = 1;
                        
                        	sound.lr_3D = true;
                        	sound.lr_distance3D = _distance;
                        	sound.lr_volumeMax3D = _volumeMax;
                        
                        	if( this._3DSounds == null)
                        		this._3DSounds = new Array();
                        	this._3DSounds.push(_name);
                        
                        }
                        
                        LR.GameObject.prototype._play3DSound = function(_sound,_loop){
                        	//compute distance between the camera&#x27;s center and the GameObject
                        	var d = Phaser.Point.distance(this.entity.world,
                        								new Phaser.Point(this.entity.game.camera.view.centerX,this.entity.game.camera.view.centerY) );
                        	var volume = 1;
                        	if( _sound.lr_distance3D &lt; d ){
                        		volume = 0;
                        	}else{
                        		volume = (1 - d / _sound.lr_distance3D ) * _sound.lr_volumeMax3D;
                        	}
                        	
                        	_sound.play(&#x27;&#x27;,0,volume,_loop);
                        }
                        
                        
                        //============================================================
                        //						SETTERS
                        //============================================================
                        /**
                        * Sets the position of the GameObject. Takes the body in account
                        *
                        * @method setPosition
                        * @param {number} x
                        * @param {number} y
                        */
                        LR.GameObject.prototype.setPosition = function(_x, _y){
                        	if( this.body != null ){
                        		this.body.x = _x;
                        		this.body.y = _y;
                        	}else{
                        		this.entity.x = _x;
                        		this.entity.y = _y;
                        	}
                        }
                        
                        /**
                        * Accessor to the entity&#x27;s position. Read only.
                        *
                        * @property position
                        * @type Phaser.Point
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;position&quot;,
                        	{
                        		get : function(){
                        			return new Phaser.Point(this.entity.x,this.entity.y);
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the entity&#x27;s body. Read only.
                        *
                        * @property body
                        * @type Phaser.Physics.P2.Body
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;body&quot;,
                        	{
                        		get : function(){
                        			return this.entity.body;
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the entity&#x27;s x.
                        *
                        * @property x
                        * @type Number
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;x&quot;,
                        	{
                        		get : function(){
                        			return this.entity.x;
                        		},
                        
                        		set : function(_x){
                        			if( this.body != null ){
                        				this.body.x = _x;
                        			}else{
                        				this.entity.x = _x;
                        			}
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the entity&#x27;s y.
                        *
                        * @property y
                        * @type Number
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;y&quot;,
                        	{
                        		get : function(){
                        			return this.entity.y;
                        		},
                        
                        		set : function(_y){
                        			if( this.body != null ){
                        				this.body.y = _y;
                        			}else{
                        				this.entity.y = _y;
                        			}
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the entity&#x27;s world coordinates property (readonly)
                        *
                        * @property world
                        * @type {Phaser.Point}
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;world&quot;,
                        	{
                        		get : function(){
                        			return this.entity.world;
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the entity&#x27;s world X coordinates
                        * Unlike world property, you can set this value to change the position of the GameObject in the world
                        *
                        * @property worldX
                        * @type {number}
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;worldX&quot;,
                        	{
                        		get : function(){
                        			return this.entity.world.x;
                        		},
                        
                        		set : function(_value){
                        			if( this.entity.parent.world == null){
                        				this.x = _value;
                        			}else{
                        				this.x = _value - this.entity.parent.world.x;
                        			}
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the entity&#x27;s world Y coordinates
                        * Unlike world property, you can set this value to change the position of the GameObject in the world
                        *
                        * @property worldX
                        * @type {number}
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;worldY&quot;,
                        	{
                        		get : function(){
                        			return this.entity.world.y;
                        		},
                        
                        		set : function(_value){
                        			if( this.entity.parent.world == null){
                        				this.y = _value;
                        			}else{
                        				this.y = _value - this.entity.parent.world.y;
                        			}
                        		}
                        	}
                        );
                        
                        
                        /**
                        * Accessor to the body&#x27;s gravity. Returns 0 if no body affected.
                        *
                        * @property gravity
                        * @type Number
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;gravity&quot;,
                        	{
                        		get : function(){
                        			if( this.entity.body == null)
                        				return 0;
                        			return this.entity.body.data.gravityScale;
                        		},
                        
                        		set : function(_gravity){
                        			if( this.entity.body != null ){
                        				this.entity.body.data.gravityScale = _gravity;
                        			}
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the body&#x27;s velocityX in world coordinates. Returns 0 if no body affected.
                        *
                        * @property velocityX
                        * @type Number
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;velocityX&quot;,
                        	{
                        		get : function(){
                        			if( this.entity.body == null)
                        				return 0;
                        			return this.entity.body.velocity.x;
                        		}
                        	}
                        );
                        
                        /**
                        * Accessor to the body&#x27;s velocityY in world coordinates. Returns 0 if no body affected.
                        *
                        * @property velocityX
                        * @type Number
                        */
                        Object.defineProperty( LR.GameObject.prototype, &quot;velocityY&quot;,
                        	{
                        		get : function(){
                        			if( this.entity.body == null)
                        				return 0;
                        			return this.entity.body.velocity.y;
                        		}
                        	}
                        );
                        
                        /**
                        * Changes the parent of the entity
                        *
                        * @method changeParent
                        * @param {LR.Entity} newParent
                        */
                        LR.GameObject.prototype.changeParent = function(_newParent){
                        	var oldParent = this.entity.parent;
                        	oldParent.remove(this.entity);
                        	_newParent.add(this.entity);
                        }
                        
                        
                        //============================================================
                        //						TWEEN
                        //============================================================
                        /**
                        * Returns true if the tween exists
                        *
                        * @method tweenExists
                        * @param {string} tweenName
                        */
                        LR.GameObject.prototype.tweenExists = function(_tweenName){
                        	return this.tweensData[_tweenName] != null;
                        }
                        
                        /**
                        * Adds a tween with the data specified
                        * example of input data : { &quot;properties&quot;:{&quot;body.x&quot;:100},&quot;duration&quot;: 1000 ...etc..}
                        *
                        * @method addTween
                        * @param {Object} tweenData Object containing the tween properties
                        */
                        LR.GameObject.prototype.addTween = function( _tweenData ){
                        	var newTween = new Object();
                        	newTween.data = JSON.parse( JSON.stringify( _tweenData) );
                        	newTween.tweensObject = new Object();
                        	newTween.count = 0;
                        	this.tweensData[_tweenData.name] = newTween;
                        
                        	if(_tweenData.autoStart == true){
                        		this.playTween(_tweenData.name);
                        	}
                        }
                        
                        /**
                        * Launch the specified tween if previously added.
                        * If there are many target in the properties, many tweens will be launched. 
                        * Then be aware that the tween returne is the one acting on the first property
                        * 
                        * @method playTween
                        * @param {string} tweenName The tween name. Use GameObject.addTween to add a tween
                        * @param {boolean} stopAll If set to true, all other playing tweens will be stopped first
                        * @param {function} callback Function to call when the tween is finished ( called at the last tween&#x27;s end if chained)
                        * @param {object} context
                        * @return {Phaser.Tween} The first launched tween induced by the tween properties
                        */
                        LR.GameObject.prototype.playTween = function(_tweenName,_stopAll,_callback,_context){
                        	var launchedTweens = new Array();
                        	if(! this.tweensData.hasOwnProperty(_tweenName)){
                        		console.error( &quot;Tween &quot; + _tweenName + &quot; not found on &quot; + this.name + &quot;[&quot; + this.id + &quot;]&quot;);
                        		return launchedTweens;
                        	}
                        	//Get tween  
                        	var tweenData = this.tweensData[_tweenName].data;
                        	var tweensObject = this.tweensData[_tweenName].tweensObject;
                        	this.tweensData[_tweenName].count = 0;
                        	if( _callback ){
                        		this.tweensData[_tweenName].callback = _callback;
                        		this.tweensData[_tweenName].context = _context;
                        	}
                        	//convert its properties
                        	var props = null;
                        	try{
                        		props = JSON.parse(tweenData.properties);
                        	}catch(e){
                        		console.error(&quot;Invalid JSON properties&quot;);
                        		return launchedTweens;
                        	}
                        	//stop all tween if asked
                        	if( _stopAll ==  true )
                        		this.stopAllTweens();
                        	//Go throught all properties and launch tweens in editor
                        	//In the properties we may have several target, so we have to launch a tween
                        	//for each different target
                        	for(var key in props){
                        		//Remove a possible running tween
                        		if(tweensObject.hasOwnProperty(key) &amp;&amp; tweensObject[key].isRunning ){
                        			this.entity.game.tweens.remove(tweensObject[key]);
                        		}
                        		//Create,add, and launch the tween
                            	var targetData = LR.Utils.getPropertyByString(this.entity,key);
                            	var createdTween = this.entity.game.add.tween( targetData.object );
                            	//Callback handling
                            	createdTween.onComplete.add(this._onTweenComplete,this);
                            	targetData.object.lr_tweenName = _tweenName;
                            	//
                            	var newProp = {};
                            	newProp[targetData.property] = props[key];
                            	//process relativeness . If a tween is marked as relative, the movement on x &amp; y will be computed from the gameobject&#x27;s current position
                        		if( tweenData.relative == true ){
                        			newProp[targetData.property] += targetData.object[targetData.property];
                        		}
                        		//console.log(tweenData);
                        		if( tweenData.repeat &lt; 0)
                        			tweenData.repeat = Number.MAX_VALUE;
                        
                        		//build easing
                        		var easing = Phaser.Easing[tweenData.easing[0]][tweenData.easing[1]];
                        		//launch tween
                            	createdTween.to(newProp, tweenData.duration, easing, true,tweenData.delay, 
                            					tweenData.repeat, tweenData.yoyo);
                            	//keep reference
                            	tweensObject[key] = createdTween;
                            	launchedTweens.push(createdTween);
                            }
                            if( launchedTweens.length &gt; 0)
                        		return launchedTweens[0];
                        	return null;
                        }
                        
                        LR.GameObject.prototype._onTweenComplete = function(_target){
                        	if(_target.lr_tweenName){
                        		var currentTween = this.tweensData[_target.lr_tweenName];
                        		currentTween.count ++;
                        		var tweens = currentTween.tweensObject;
                        		var tweenData = currentTween.data;
                        		//Counting ( onComplete is called mutliple times for a repeating tween)
                        		if(tweenData.repeat &gt; 0 &amp;&amp; currentTween.count &lt; Object.keys(tweens).length)
                        			return;
                        		currentTween.count = 0;
                        
                        		if( tweenData.chain == null){
                        			this.onTweenComplete.dispatch({&quot;tweenData&quot;:tweenData});
                        			if( currentTween.callback){
                        				currentTween.callback.call(currentTween.context);
                        				currentTween.callback = null;
                        				currentTween.context = null;
                        			}
                        		}
                        		
                        		//if a tween has finished, the other ones are two ( they take the same ammount of time)
                        		for(var key in tweens){
                        			if( tweens[key]!=null){
                        				tweens[key].stop();
                        				this.entity.game.tweens.remove(tweens[key]);
                        				tweens[key] == null;
                        				delete tweens[key];
                        			}
                        		}
                        		//if a chained tween is there
                        		if( tweenData.chain != null &amp;&amp; tweenData.chain != &quot;&quot;){
                        			//if a callback is set, move it to the chained tween
                        			if(currentTween.callback != null &amp;&amp; currentTween.context != null){
                        				var chainedTween = this.tweensData[tweenData.chain];
                        				chainedTween.callback = currentTween.callback;
                        				chainedTween.context = currentTween.context;
                        				//clean
                        				currentTween.callback = null;
                        				currentTween.context = null;
                        			}
                        			this.playTween(tweenData.chain);
                        		}
                        	}
                        }
                        
                        /**
                        * Chains the specified tweens and launch the first one
                        * Warning : this will override any tween previous chaining
                        * 
                        * @method playChainedTweens
                        * @param {string} tweenNames The tween names. As many as you want to chain
                        * @return {Array} An array of the first tweens
                        */
                        LR.GameObject.prototype.playChainedTweens = function(){
                        	var firstTween = null;
                        	var currentTween = null;
                        	for (var i = 0; i &lt; arguments.length; i++) {
                        		var tweenName = arguments[i];
                            	if( i==0 ){
                            		firstTween = this.tweensData[tweenName].data;
                            	}
                            	if(currentTween != null){
                            		currentTween.chain = arguments[i];
                            	}
                            	currentTween = this.tweensData[tweenName].data;
                          	}
                          	this.playTween(arguments[0]);
                        }
                        
                        /**
                        * Stops the specified tween
                        *
                        * @method stopTween
                        * @param {string} Tween name
                        */
                        LR.GameObject.prototype.stopTween = function(_tweenName){
                        	var tweens = this.tweensData[_tweenName].tweensObject;
                        	for(var key in tweens){
                        		tweens[key].stop();
                        		this.entity.game.tweens.remove(tweens[key]);
                        		tweens[key] == null;
                        		delete tweens[key];
                        	}
                        }
                        
                        /**
                        * Stops all the playing tweens
                        *
                        * @method stopAllTweens
                        */
                        LR.GameObject.prototype.stopAllTweens = function(){
                        	for(var key in this.tweensData ){
                        		this.stopTween(key);
                        	}
                        }
                        
                        /**
                        * Returns true if the specified tween is playing
                        *
                        * @method isTweenPlaying
                        * @param {string} Tween name
                        */
                        LR.GameObject.prototype.isTweenPlaying = function(_tweenName){
                        	var tween = this.tweensData[_tweenName];
                        	if( tween == null )
                        		return false;
                        	if( tween.tweensObject &amp;&amp; Object.keys(tween.tweensObject).length &gt; 0){
                        		return tween.tweensObject[ Object.keys(tween.tweensObject)[0] ].isRunning;
                        	}
                        	return false;
                        }
                        
                        /**
                        * Tween the color of the entity (if possible)
                        * You can specify a start color if you want to
                        *
                        * @method playTweenColor
                        * @param {Color} endColor ie: 0xffffff
                        * @param {Number} duration Duration of the tween
                        * @param {Color} startColor ie: 0xffffff if null, the current tint is taken
                        * @param {Number} repeat How many times the tween has to be repeated
                        * @param {boolean} yoyo Is yoyo enabled
                        *
                        *@return {Phaser.Tween} The generated tween
                        */
                        LR.GameObject.prototype.playTweenColor = function(_toColor, _duration, _startColor,_repeat,_yoyo) {
                            if( _startColor == null ) _startColor = this.entity.tint;
                            if(_repeat == null) _repeat = 0;
                            if(_yoyo == null) _yoyo = false;
                        
                            // create an object to tween with our step value at 0
                            var colorBlend = {step: 0};
                        
                            // create the tween on this object and tween its step property to 100
                            var colorTween = this.entity.game.add.tween(colorBlend).to({step: 99}, _duration, Phaser.Easing.Default,false,0,_repeat,_yoyo);
                            
                            var target = this.entity;
                            // run the interpolateColor function every time the tween updates, feeding it the
                            // updated value of our tween each time, and set the result as our tint
                            colorTween.onUpdateCallback(function() {
                              target.tint = Phaser.Color.interpolateColor(_startColor, _toColor, 100, colorBlend.step);   
                            });
                            
                            // set the object to the start color straight away
                            this.entity.tint = _startColor;  
                            
                            // start the tween
                            colorTween.start();
                            return colorTween;
                        }
                        
                        //============================================================
                        //						ANIMATIONS
                        //============================================================
                        /**
                        * Plays the specified animation
                        *
                        * @method playAnim
                        * @param {string} animName The name of the animation
                        * @return {Phaser.Animation} The Animation object
                        */
                        LR.GameObject.prototype.playAnim = function(_animName){
                        	this.entity.animations.play(_animName);
                        	return this.entity.animations.getAnimation(_animName);
                        }
                        
                        /**
                        * Stops the specified animation
                        *
                        * @method stopAnim
                        * @param {string} animName The name of the animation
                        * @param {boolean} resetFrame Sets the first frame of the animation when stopping it
                        * @return {Phaser.Animation} The Animation object
                        */
                        LR.GameObject.prototype.stopAnim = function(_animName,_resetFrame){
                        	this.entity.animations.stop(_animName,_resetFrame);
                        	return this.entity.animations.getAnimation(_animName);
                        }
                        
                        /**
                        * Returns the animation object
                        *
                        * @method getAnim
                        * @param {string} animName The name of the animation
                        * @return {Phaser.Animation} The Animation object
                        */
                        LR.GameObject.prototype.getAnim = function(_animName){
                        	this.entity.animations.getAnimation(_animName);
                        }
                        
                        //============================================================
                        //						CUTSCENE
                        //============================================================
                        /**
                        * Called when a cutscene begins
                        *
                        * @method onBeginCutscene
                        */
                        LR.GameObject.prototype.onBeginCutscene = function(){
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		if( this.behaviours[i].onBeginCutscene != null )
                        			this.behaviours[i].onBeginCutscene();
                        	}
                        }
                        
                        /**
                        * Called when a cutscene ends
                        *
                        * @method onEndCutscene
                        */
                        LR.GameObject.prototype.onEndCutscene = function(){
                        	for(var i=0; i &lt; this.behaviours.length; i++){
                        		if( this.behaviours[i].onEndCutscene != null )
                        			this.behaviours[i].onEndCutscene();
                        	}
                        }
                        
                        //============================================================
                        //						GLOBALS
                        //============================================================
                        
                        /**
                        * Find a gameobject by its name
                        *
                        * @method &lt;static&gt; FindByName
                        * @param {LR.GameObject | LR.Entity } root Root of the search
                        * @param {string} name Gameobject&#x27;s name to find
                        * @return {LR.GameObject } Found gameobject
                        */
                        LR.GameObject.FindByName = function(_root, _name) {
                        	var gameobject = null;
                        
                        	if( _root instanceof LR.GameObject )
                        		_root = _root.entity;
                        
                        	if( _root &amp;&amp; _root.go &amp;&amp; _root.go.name === _name) {
                        		gameobject = _root.go;
                        	} else if(_root.children) {
                        		var i = 0;
                        		while (i &lt; _root.children.length &amp;&amp; gameobject == null) {
                        			var child = _root.children[i];
                        			var go = LR.GameObject.FindByName(child, _name);
                        			if(go)
                        				gameobject = go;
                        			i++;
                        		}
                        	}
                        	
                        	return gameobject;
                        };
                        
                        /**
                        * Find a gameobject by its ID
                        *
                        * @method &lt;static&gt; FindByID
                        * @param {LR.GameObject | LR.Entity} root Root of the search
                        * @param {Number} name Gameobject&#x27;s ID to find
                        * @return {LR.GameObject} Found gameobject
                        */
                        LR.GameObject.FindByID = function(_root, _id) {
                        	var gameobject = null;
                        
                        	if( _root instanceof LR.GameObject )
                        		_root = _root.entity;
                        
                        	if (_root &amp;&amp; _root.go &amp;&amp; _root.go.id === _id) {
                        		gameobject = _root.go;
                        	} else {
                        		if (_root.children) {
                        			var i = 0;
                        			while (i &lt; _root.children.length &amp;&amp; gameobject == null) {
                        				var child = _root.children[i];
                        				var go = LR.GameObject.FindByID(child, _id);
                        				if (go) {
                        					gameobject = go;
                        				}
                        
                        				i++;
                        			};
                        		}
                        	}
                        	return gameobject;
                        };
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
